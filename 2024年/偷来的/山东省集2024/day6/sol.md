# 题解

## A. 经典(classic)

### 分析

需要维护字符串 $B$ 在 $A$ 中出现次数，且 $B$ 和 $A$ 可以在首尾插入字符。

首先，由于问题没有强制在线，$B$ 和 $A$ 插入字符和询问可以视为对于最终状态的 $A,B$ 多次各自截取一段区间进行询问。

而截取给定长串的两个子串询问出现次数，自然可以用后缀树结构分析。

### 思路

首先不妨把 $A,B$ 拼成一个大串 $S=A+B$。然后，设询问的是 $S$ 中 $S[x:y]$ 在 $S[l:r]$ 中出现了多少次，则答案等于 $i\in [l,r-(y-x)]$ 中满足 $LCP(S[i:],S[x:])\ge y-x+1$ 的 $i$ 的个数，注意 $S[i:]$ 表示 $S$ 从 $i$ 开始的后缀。

由于对于一个询问来说 $S[x:], y-x+1$ 都是常数，可以发现全局所有满足 $LCP(S[i:], S[x:])\ge y-x+1$ 的 $i$ 在后缀数组（或者后缀树DFS序）中是连续的一段。可以通过二分等方法求出这一段的具体范围。这样，问题可以转化成后缀排名数组（或者后缀树DFS序列）中一个区间内有多少数值域在给定范围 $[l,r-(y-x)]$ 内。也就是二维数点问题。

二维数点问题套用离线区间数据结构做法即可。

### 算法

先求出 $S=A+B$ 的后缀排名数组。

对于每次询问，先求出 $S$ 中对应的 $S[x:y],S[l:r]$，二分出后缀排名数组中满足 $LCP(S[i:], S[x:])\ge y-x+1$ 的 $i$ 的范围，得到给定的二维数点查询。

然后对所有的二维数点查询套用离线区间数据结构做法求解，再对应回每个初始询问的答案。

参考：国家集训队 2013 two string

额外开放性思考题：

1. 强制在线是否可做？可以做到什么时间复杂度？

2. 不考虑 $A$ 的子串/后缀数据结构，而是考虑 $B$ 的超串（KMP/AC自动机）结构，是否可能做？如果困难，有什么可能的变通方式？

## B. 点分治树(dac)

### 分析

研究对象是点分治树带上层级值的方案。两个并在一起的方案太复杂了，需要简化。

通过打表等方式，或者当你比较熟悉分治搜索树的结构时，我们可以发现，**每种层级值标注方案唯一对应一个点分治树结构**。

具体来说：
- 如果存在两个相等的最小的层级值，那么一定不合法，因为点分治树的根一定是全局唯一层级值最小值。
- 如果恰好存在一个最小的层级值，那么这个点一定是点分治树的根，然后删去这个点后各连通块分别递归建树。

所以实际上，我们只需要求合法的层级值组数。

根据上述构造过程，可以得到，一组层级值是合法的当且仅当任意两个相等的数之间都存在比它们小的数。

然后我们考虑如果自己知道了一个层级值标号方案，能否在一次DFS过程中（以便状态压缩后树上递推）判定它的合法性。

### 思路

接上文。

- 我们称两个层级值相等的点之间不存在比它们小的数的情况为非法点对。
- 假设我们 DFS 统计完了以 $i$ 为根的子树，且子树内不存在非法点对，那么子树内的某个点 $u$ 对子树外可能有影响——也就是可能和子树外的某个点形成非法点对，当且仅当 $u$ 到 $i$ 路径上的点都不小于 $u$。进一步地，如果 $u$ 到 $i$ 路径上有层级值等于 $u$ 的点 $v$，那么任何子树外和 $u$ 形成非法点对也能和 $v$ 形成非法点对。换言之，我们只需要记录从 $i$ 向子树方向走到的“前缀最小值”点信息。
- 进一步地，我们可以发现，实际上到底是子树内哪个点对于判定合法性并不重要。我们只需要记录从 $i$ 向子树方向走能遇到的前缀最小值的值域集合即可。我们称所有从 $i$ 向子树方向走能遇到的前缀最小值的集合为 $M(i)$。
- 在 $LCA=u$ 处不合法当且仅当 $u$ 的某个子树的 $M$ 集合和已合并部分的 $M$ 集合相交（我们可以将 $u$ 子树回溯到 $u$ 的过程视为将 $u$ 的子树逐个和“已合并部分”（初始只有 $u$ 一个点）合并）。
- 记录子树合法性并回溯即可。

### 算法

按照 DP 的状态机理论，对上文 DFS 判定过程的内存状态进行状压 DP 即可。

设 $f(i,j,S)$ 表示子树 $i$（注意原树是无根树，所以求所有子树需要多做一遍“换根 DP”）内没有非法点对且 $h_i=j,M(i)=S$ 的方案数。

树形 DP 求出所有的 $f(i,j,S)$，然后枚举根统计答案即可。转移参考上文 DFS 合并过程，按顺序枚举子树合并，并记录“已合并部分”的 $M$ 集合。

注意转移过程中需要用子集和（高维前缀和）优化计算。

时间复杂度：$O(nk^22^k)$（状态数 $\sim nk2^k$，求子集和额外乘 $k$ 倍复杂度）

参考：AGC009D

## C. 最小生成森林并(forest)

### 分析

首先，最大化目标是两个最大值的和的形式。容易看到，$\max F_G$ 增加时，要达到条件所需的 $\max F_H$ 单调不降。所以整个问题是双指针的形式。

另外，容易注意到只有 $G,H$ 各自最小生成树（或者说边数最大的最小生成森林）上的边是有用的，也就是那些插入后会改变自己图上比自己小的所有边连成的连通性的边才有用。

只保留最小生成树，并双指针后，问题转化为：$G,H$ 两棵树，每次插入一条 $G$ 中的边，删除/撤销删除一条 $H$ 中的边，维护可达点对个数。

### 思路


首先，因为 $F_G,F_H$ 各自内部的连通点对数容易计算，计算总的“可达点对个数”和计算“同时在 $F_G,F_H$ 连通的点对个数”难度相等（根据两个条件容斥关系）。可以注意到，“同时在 $F_G,F_H$ 连通的点对”具有传递性，是等价类，所以个数等于每个等价类选 $2$ 的方案数之和。

考虑怎么维护“同时在 $F_G,F_H$ 中联通的点对”的等价类，设等价类集合为 $S$。首先每个等价类的点在 $F_G,F_H$ 中各自也一定是连通的。

- 所以如果我们只有“插入一条边到 $F_G$”“插入一条边到 $F_H$”两种操作，我们只需要插入的时候查询一下在另外一个图上那两点是否已经连通，连通就合并两个等价类，用并查集即可维护 $S$。
- 但是我们需要删边，考虑删边怎么维护。你可以发现，删一条边的时候，要么 $S$ 不变（当且仅当删掉的边两端不在一个等价类），要么 $S$ 中的某个等价类分裂成两个，并且**这两个等价类分别是原来的等价类与（删掉的边在自己所在的最小生成树中对应的两侧）各自的交**。更进一步地，注意到我们只会删 $H$ 中的边，而且无论如何每个等价类都可以表达成 $H$ 的连通块的一个子点集。
- 所以我们可以改用动态树（比如 ETT）维护等价类，每个等价类可以表达成等价类里所有点在 $H$ 上的虚树，且每个等价类的虚树之间互不相交。仔细分析可以发现其实并不需要 ETT，在 $H$ 的边权笛卡尔树（Kruskal 重构树）上做子树分裂/启发式分裂即可，每次分裂操作分开的点集是固定的。
- 插入 $G$ 边带来的合并直接用启发式合并即可。
- 启发式合并和启发式分裂的复杂度等于较小那一侧的等价类点数，分别都不超过 $G,H$ 各自 Kruskal 重构树上的分裂点轻儿子大小之和，所以都是 $O(n \log n)$

需要处理一下双指针的尝试删除并反复撤销对均摊复杂度的影响。具体来说，在 $H$ 的指针停滞不前的时候，可以不一直尝试删除 $H$ 而是直接把 $H$ 的这条边删除，然后改为移动 $G$ 的指针进行尝试直到合法，这样就没问题了。

~~如果你不想动脑子可以直接换成单步严格复杂度的动态树，比如 ETT。~~

### 算法

首先求出 $G,H$ 各自的边数最多的最小生成森林，只保留其中的边。

然后用某种能维护虚树分裂，能启发式合并的数据结构维护“同时在 $F_G,F_H$ 连通的点对”等价类。

然后双指针。问题转化为：$G,H$ 两棵树，每次插入一条 $G$ 中的边，删除/撤销删除一条 $H$ 中的边，维护可达点对个数。

时间复杂度：$O(n\log n)$