# NOI 模拟赛 by CQYC

|     题目名称      | 最长上升紫序列 | 黑暗普通市民 |    急气     |
| :---------------: | :------------: | :----------: | :---------: |
|     题目类型      |     传统型     |    传统型    |   传统型    |
|   可执行文件名    |      seq       |   special    |   machine   |
|    输入文件名     |     seq.in     |  special.in  | machine.in  |
|    输出文件名     |    seq.out     | special.out  | machine.out |
|  每个测试点时限   |      1 秒      |     1 秒     |   2.5 秒    |
|     内存限制      |     256 MB     |    256 MB    |   1024 MB   |
| 子任务/测试点数目 |       4        |      6       |      7      |
|     是否等分      |       否       |      否      |     否      |

提交源文件程序名

| 对于C++语言 | seq.cpp | special.cpp | machine.cpp |
| ----------- | ------- | ----------- | ----------- |

编译选项

| 对于C++语言 | -lm -std=c++14 -O2 -Wl,--stack=2147483647 |
| ----------- | ----------------------------------------- |

**注意事项(请仔细阅读)**

1. ⽂件名（程序名和输⼊输出⽂件名）必须使用英文小写。
2. C/C++ 中函数 `main()` 的返回类型必须是 `int` ，程序正常结束时返回值必须是0。
3. 选手提交的程序代码文件请**直接放在个人目录下，不需要建立子文件夹**。
4. 若无特殊说明，结果的比较方式为全文比较（过滤行末空格及文末回车）。
5. 选手提交的程序源文件必须不大于 50KB。
6. 程序可使用的栈空间内存限制于题目的内存限制一致。
7. 使用 `std::deque` 等 STL 容器时，请注意其内存空间消耗。
8. 评测在 Windows 11 下进行，使用 LemonLime 进行评测。
9. 若开启捆绑测试，为了避免数据过多，评测时可能会有符合数据范围的子任务依赖。
10. 题目较简单，喧哗的选手请不要大声 AK。

<div STYLE="page-break-after: always;"></div>

## 最长上升紫序列（seq）

### 题目背景

最长上升紫序列就是最长的单调递增的紫序列。


### 题目描述

给定一个长度为 $n$ 的正整数序列 $a_1,a_2,...,a_n$，你每次可以将序列中 $a_1$ 至 $a_{n-1}$ 中的数修改成任意**正整数**。注意，**不能**修改 $a_n$​。请你求出使序列严格单调递增的最少操作次数。


### 输入格式

输入共两行。

第一行一个整数 $n$，表示序列长度。

第二行 $n$ 个整数 $a_1,a_2,...,a_n$，表示序列的初始值。

### 输出格式

一行一个非负整数，表示答案。

### 样例 #1

#### 样例输入 #1

```
4
1 2 3 4
```

#### 样例输出 #1

```
0
```

### 样例 #2

#### 样例输入 #2

```
4
2 3 3 4
```

#### 样例输出 #2

```
2
```

### 样例解释

样例 1 中，序列初始时就已经单调递增了，无需修改。

样例 2 中，可以使 $a_1=1,a_2=2$，序列变为 $1,2,3,4$，满足条件，可以证明不存在更优的方案。

### 数据范围

本题采用**捆绑测试**。

对于 $100\%$ 的数据，$1\le n\le 3\times 10^5$，$1\le a_i\le 2n$，$a_n\ge n$。

Subtask 1（10 pts）：$n\le 5$。 

Subtask 2（15 pts）：$n\le 200$。 

Subtask 3（25 pts）：$n\le 2000$。 

Subtask 4（50 pts）：无特殊限制。

<div STYLE="page-break-after: always;"></div>

## 黑暗普通市民（special）

### 题目描述

> 我是路过的普通吸血鬼，不是什么可疑分子。

因为听说小树林里有漂亮的像人偶一样的女孩子，灯来到郊区探险。

小树林中的 $n-1$ 条小路连通了 $n$ 个路口，将路口从 $1$ 到 $n$ 编号后，这些小路构成了路径——一颗以 $1$ 号路口为根的树 $T$。为了便于探险，灯决定估算出小树林内路径（即树 $T$）的复杂度。路径的复杂度定义如下：

首先，灯给每个路口设定了一个权值 $0/1$ 来表示这个路口环境的复杂与否，初始时有一个空序列，每次任意选择一个没有父亲的点（路口），把它的权值加入序列末，然后删掉这个点，树 $T$ 的复杂度定义为在 $n$ 次操作后，所得的序列的逆序对的最小数量。

灯被这种算法弄迷糊了，但是她隐约感受到树林深处有着什么对她意义非凡的事物，这让她充满了决心，所以，可以请你帮她算出这些路径的复杂度吗？

### 输入格式

第一行一个整数 $n$；

第二行 $n-1$ 个整数 $P_2,P_3...P_n$，$P_i$ 表示 $i$ 号路口（点）的父亲；

第三行 $n$​ 个整数 $Q_1,Q_2...Q_n$​，$Q_i$​ 表示 $i$​ 号路口的权值。

### 输出格式

输出一行一个数表示路径的复杂度。

### 样例见下发文件

样例 $1$ 满足 子任务 $1$ 的限制；

样例 $2$ 满足 子任务 $2$ 的限制；

样例 $3$ 满足 子任务 $3$ 的限制；

样例 $4$ 满足 子任务 $4$ 的限制；

样例 $5$ 满足 子任务 $5$ 的限制；

样例 $6$ 满足 子任务 $6$​ 的限制；

### 样例解释

样例 $1$ 中的最优删点方案之一为 $1,3,5,6,2,4$，所得序列为 $0,1,0,0,1,0$，最优方案可能不唯一，为了便于理解，这里附上每次删点之后的图：

![](.\7ced0f64138631378b040c682fdaab3a.png)

### 数据范围

对于所有数据，$1\leq n\leq 2\times 10^5,1\leq P_i<i,Q_i\in \{0,1\}$。

### 子任务

**本题采用捆绑测试**。

| 子任务编号 | 特殊性质                                                     | 子任务分值 |
| :--------: | :----------------------------------------------------------- | :--------: |
|     1      | $n \leq 10$                                                  |     10     |
|     2      | $n\leq 1000$                                                 |     20     |
|     3      | $n\leq 2\times 10^5$，保证权值为 $1$ 的点不超过 $5$ 个       |     20     |
|     4      | $n\leq 2\times 10^5$，且对于 $2\le i \le n$，满足 $P_i =i-1$ |     5      |
|     5      | $n\leq 2\times 10^5$，保证仅有点 $1$ 的度数 $> 2$            |     10     |
|     6      | 无                                                           |     35     |

<div STYLE="page-break-after: always;"></div>

## 急气（machine）

### 题目描述

你是一个绳匠，目前拥有一台由 $N$ 个显示屏组成的急气，每块显示屏初始颜色为 **红色** 或 **蓝色** 中的一种，另外有 $M$ 个操作按钮，当按下按钮 $i$ 时会发生以下事件： 

1. 出现一个邦布刷新在第 $A_i$ 块显示屏区域，此处显示屏的颜色变为 **红色**；

2. 邦布会重复以下操作，直至跑出监控范围（超出左边界或右边界）：
	- 如果邦布位于 **蓝色** 区域上，该显示屏的颜色变为 **红色**，邦布跑到 **左边** 一个显示屏区域内；
	- 如果邦布位于 **红色** 区域上，该显示屏的颜色变为 **蓝色**，邦布跑到 **右边** 一个显示屏区域内；
   

某一天，你发现你的急气被黑客入侵了！！！黑客要求你回答 $Q$ 次询问，对于每个询问，给定 $L_i,R_i$，让你说出顺次按下按钮 $L_i,L_i+1,...,R_i$ 后 **红色** 显示屏的数量，如果答不上，他将会在你的急气上安装一堆原神来占你内存！情急之下你灵机一动，打算写一个代码回答黑客的问题。

### 输入格式

第一行两个整数 $N$ 和 $M$；

第二行一个长度为 $N$ 字符串 $S$，第 $i$ 个字符为 ```'R'``` 或 ```'B'``` 分别表示第 $i$ 块显示屏为 **红色**(Red) 或 **蓝色**(Blue) ；

第三行一个长度为 $M$ 的用 **空格** 分割的数列 $A$；

第四行一个整数 $Q$；

接下来 $Q$ 行，每行两个整数 $L_i$，$R_i$；

具象化的：

> $N$​ $M$​ 
>
> $S$​ 
>
> $A_1\ A_2 \dots A_M$​ 
>
> $Q$​ 
>
> $L_1\ R_1$​ 
>
> $L_2\ R_2$​ 
>
> $\dots$​ 
>
> $L_Q\ R_Q$​

### 输出格式

$Q$ 行，第 $i$ 行一个整数（询问 $L_i,R_i$ 的答案）

### 样例见下发文件

样例 $1$ 满足 子任务 $1,2,3,6,7$ 的限制；

样例 $2$ 满足 子任务 $3,6,7$ 的限制；

样例 $3$ 满足 子任务 $1,2,3,6,7$ 的限制；

样例 $4$ 满足 子任务 $3,4,5,6,7$ 的限制；

样例 $5$ 满足 子任务 $3,5,6,7$ 的限制；

样例 $6$ 满足 子任务 $6,7$​ 的限制；

样例 $7$ 满足 子任务 $7$ 的限制；

### 样例解释

对于样例 $1$：

1. 按下按钮 $1$，邦布刷新在了 $4$ 号显示屏区域内

2. $4$ 号显示屏变为红色~~（其实并没有变化）~~

3. 接下来发生以下事件

	- $4$ 号显示屏变为蓝色，邦布跑到 $5$ 号显示屏区域内

	- $5$ 号显示屏变为红色，邦布跑到 $4$ 号显示屏区域内

	- $4$ 号显示屏变为红色，邦布跑到 $3$ 号显示屏区域内

	- $3$ 号显示屏变为蓝色，邦布跑到 $4$ 号显示屏区域内

	- $4$ 号显示屏变为蓝色，邦布跑到 $5$ 号显示屏区域内

	- $5$ 号显示屏变为蓝色，邦布跑出显示屏监控范围

 此时：仅有 $1$ 号显示屏为红色，输出一行一个整数 $1$

### 数据范围
对全部的测试点，保证：

- $3 \leq N \leq 1.2 \times 10^5$；

- $1 \leq M \leq 1.2 \times 10^5$；

- $S_i \in \{\texttt{B},\texttt{R}\}$；

- $1 \leq A_i \leq N$；

- $1 \leq Q \leq 1.2 \times 10^5$；

- $1 \leq L_i \leq R_i \leq M$；

- $N, M, A_i, Q, L_i, R_i$ 均为整数。

### 子任务

**本题采用捆绑测试**。

| 子任务编号 | 特殊性质 | 子任务分值 | 子任务依赖 |
| :-----------: | :----------- | :-----------: | :-----------: |
| 1 | $N,M \leq 300$，$Q = 1$ | 3 | 无 |
| 2 | $N, M \leq 7000$，$Q = 1$ | 12 | 1 |
| 3 | $Q \leq 5$ | 10 | 2 |
| 4 | $N = 10$，$S_i = \texttt R$ | 11 | 无 |
| 5 | 存在一个整数 $t \in [0, N]$，满足对 $1 \leq i \leq t$，$S_i = \texttt R$；且对 $t < i \leq N$，$S_i = \texttt B$ | 26 | 无 |  |
| 6 | $A_i \leq 20$ 或 $A_i > N - 20$ | 17 | 4 |
| 7 | 无 | 21 | 3，5，6 |