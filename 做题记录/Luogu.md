## [P4069 [SDOI2016] 游戏]([P4069 [SDOI2016\] 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4069))

涉及算法：李超线段树、重链剖分

首先因为点 $r$ 到点 $s$ 的 $dis$ 不好弄，看到 $a\times dis+b$ 是一次函数，很像李超线段树做的东西，那么我们把 $s$ 到 $t$ 分为 $s$ 到 $lca$ 和 $t$ 到 $lca$ 两段，将第一、二段的 $dis_{r,s}$ 分别转化为 $dis_{1,s}-dis_{1,r}$、$dis_{1,s}+dis_{1,r}-2\times dis_{1, lca}$，那么第一、二段的函数分别为 $-a\times dis_{1,r}+a\times dis_{1, s}+b$、$a\times dis_{1,r}+a\times (dis_{1,s}-2\times dis_{1, lca})+b$，又因为 $lca$ 到 $s$、$t$ 的路径上的 $dis_{1,r}$ 都递增，所以可以使用李超线段树套上个重链剖分，而要求的最小值可以标记永久化，并且插入线段的最值一定在线段的两个端点 QwQ

完结撒花✿✿ヽ(°▽°)ノ✿

## [P3527 [POI2011] MET-Meteors]([P3527 [POI2011\] MET-Meteors - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3527))

涉及算法：整体二分、树状数组

可以发现这道题能够二分，但每个询问都单独二分的话时间复杂度受不了（关键在于 check 的时间复杂度），所以使用整体二分，将每次操作看作差分用树状数组来维护，再用一个指针每次添加或者删除操作即可

完结撒花✿✿ヽ(°▽°)ノ✿

## [P4183 [USACO18JAN] Cow at Large P](https://www.luogu.com.cn/problem/P4183)

涉及算法：点分治、树状数组

题面略了，根据题意，首先我们能想到一个 $O(n^2)$ 的方法：先预处理每个点 $i$ 到叶子结点的最小值 $g_i$，然后枚举根 $rt$，当 $dis_{rt,i} \ge g_i$ 时，农夫一定能从叶子结点走到当前节点，那么当前节点及其子树肯定就不会被贝茜走到，于是直接 ***dfs***，走到点 $i$ 满足 $dis_{rt,i} \ge g_i$，则答案 $+1$，并且不继续遍历子树

当前做法瓶颈在于要枚举根节点才能确定每个点的子树，那么我们就要让答案和枚举的根节点无关，首先考虑让答案和“子树”限制无关，能发现之前走到的满足 $dis_{rt,i} \ge g_i$ 的点 $i$ 的儿子们也满足该条件，而该子树对答案贡献的 $1$ 可以看作是点数减边数，那么我们把每个叶子点赋为 $1$，其他点都赋为 $1-儿子数=2-度数$ 就可以直接求满足 $dis_{rt,i} \ge g_i$ 的所有点的权值和了，具体做法直接上点分治，把 $dis_{rt,i}\ge g_i$ 转化为 $dep_{rt}+dep_i\ge g_i$，即 $dep_{rt} \ge g_i-dep_i$，然后套上个树状数组就做完啦（值得注意的是 $g_i-dep_i$ 有可能小于等于 $0$，所以要 $+n$）

完结撒花✿✿ヽ(°▽°)ノ✿

## [P5384 [Cnoi2019] 雪松果树](https://www.luogu.com.cn/problem/P5384)

涉及算法：线段树合并

题面略，这题原本空间限制为 $128$ MB，后面改了，所以可以直接线段树合并做

发现答案就是查询以 $k$ 级祖先为子树的与 $u$ 深度相同的点的个数 $-1$（不能算自己），然后线段树合并就可以做啦~找 $k$ 级祖先可以直接 dfs 一遍 QwQ

完结撒花✿✿ヽ(°▽°)ノ✿

### [P4548 [CTSC2006] 歌唱王国](https://www.luogu.com.cn/problem/P4548)

涉及算法：概率生成函数、KMP

#### 题意简述

字符集大小为 $n$，处理 $t$ 组数据，每组数据给出一个长度为 $m$ 的字符集 $S$，空串 $T$ 每次随机加入一个字符，直到 $T$ 中出现 $S$ 停止，求 $T$ 停止时长度的期望。

#### 做法

显然不能直接硬算，先设变量 $Y$ 表示停止时 $T$ 的长度，再引入两个概率生成函数 $f(x)$、$g(x)$ 分别表示 $Y=i$ 的概率和 $Y>i$ 的概率，即 $f(x)=\sum^{+\infty}_{i=0}P(Y=i)x^i$，$g(x)=\sum^{+\infty}_{i=0}P(Y>i)x^i$，为了方便我们分别用 $f_i$、$g_i$ 表示 $f$、$g$ 的 $i$ 次项的系数，那么 $f_i$ 就表示在第 $i$ 次添加停止的概率，$g_i$ 就表示在第 $i$ 次添加仍未停止的概率，最终我们要求的期望 $E(Y)=f'(1)$，接下来的任务便是找式子求期望了。

##### 第一个式子——转化期望

首先我们可以根据 $f$、$g$ 的定义来确定一个递推式，因为 $Y$ 一定是一个正整数，所以 $Y>i$ 等价于 $Y\ge i+1$，手动分类讨论一下（等于和大于的情况）可得 $g_i=f_{i+1}+g_{i+1}$，整理成生成函数得到 $xg(x)+1=f(x)+g(x)$（$+1$ 是补上 $g_0=1$ 的项），由于我们要求 $f'(1)$，那么就可以用 $g$ 来表示 $f$，即
$$
f(x)=(x-1)g(x)+1
$$
求个导可得 $f'(x)=g(x)+(x-1)g'(x)$，最终我们有 $f'(1)=g(1)$，皆大欢喜 :D，这意味着只要我们能求出 $g(1)$ 就能得到答案了。

##### 第二个式子——求 $g(1)$

接下来我们又设一个数列 $h_i$ 表示在第 $i$ 次操作后仍未结束，强制性地给 $T$ 随机加上长度为 $m$ 的串 $S$ 的概率（强制表示可能有尚未加满 $m$ 个字符就已经出现了 $S$ 的情况，但仍然继续加字符直到加满了 $m$ 个字符，并且根据定义，加入的 $m$ 个字符能组成串 $S$），那么就相当于我们在 $g_i$ 的情况下强制加了 $m$ 个字符，于是能得到 $h_i=g_i\times n^{-m}$。

但同时我们能发现此时能够满足 $h_i$ 条件的 $Y$ 应该有 $i<Y\le i+m$，对于 $Y$ 的每一种值我们可以单独讨论，假设 $Y=y$、$t=y-i$（$0<t\le m$），前提概率便是 $f_y$，我们只需求再补上串 $S$ 的长为 $m-t$ 的后缀使得加入这 $m-t$ 个字符后最后 $m$ 个字符能形成串 $S$ 的 $f_y\times n^{t-m}$ 之和就能得到 $h_i$，由于在第 $y$ 次加入时已经满足出现长度为 $m$ 的子串 $S$，那么显然第 $i+1\sim y$ 次加入的字符构成的串同时为串 $S$ 的前、后缀，换种说法即为 $t$ 属于串 $S$ 的 Border 或者 $t=m$（这么说是因为 Border 的定义要求字符串本身不为该字符串的 Border），形式化地：$h_i=\sum\limits^m_{t=1} pd(t)f_y\times n^{t-m}$，其中 $pd(t)$ 取值为 $0$ 或 $1$，表示判断 $t$ 是否满足 $t=m$ 或 $t$ 为 $S$ 的 Border 的条件。

结合这两种 $h_i$ 的求法，可得到 $g_i\times n^{-m}=\sum\limits^m_{t=1} pd(t)f_y\times n^{t-m}=n^{-m}\times\big(\sum\limits^m_{t=1} pd(t)f_y\times n^t\big)$，又知道 $y=i+t$，于是 $g_i=\sum\limits^m_{t=1} pd(t)f_{i+t}\times n^t$，转化为生成函数形式：
$$
x^{m}g(x)=\sum^m_{t=1}x^{m-t}f(x)pd(t)\times n^t
$$
代入可得 $g(1)=\sum\limits^m_{t=1}f(1)pd(t)\times n^t=\sum\limits^m_{t=1}pd(t)\times n^t$，综上，最终的答案便为 $\sum\limits^m_{t=1}pd(t)\times n^t$，直接上 KMP 就做完啦。

完结撒花✿✿ヽ(°▽°)ノ✿