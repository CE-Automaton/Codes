## [Manacher 算法](https://www.luogu.com.cn/problem/P3805)

该算法由 Glenn K. Manacher 在 1975 年提出，首先注意到回文串的对称中心特性可能有所不同（中心可能为一个字符或者是在两个字符之间），那么我们将字母之间插入隔板，这两个回文串的对称中心就都在一个字符上了，such as "|A|B|B|A|"、"|A|B|C|B|A|"

### 过程

对于一个回文串，有且仅有一个对称中心，我们称之为**回文对称中心**。

在一个回文串内，任选一段区间 $X$，一定存在关于“回文对称中心”对称的一个区间 $Y$，我们把区间 $Y$ 叫关于区间 $X$ 的对称区间。

可得：

- 区间和对称区间一定全等。
- 若一个区间的对称区间是回文串，这个区间必定是一个回文串。在大的回文串内（即不考虑其他字符）它们回文半径相等
- 我们通过确定关系预先得到的回文半径的数值必定**小于等于**这个位置真实的回文半径。

因此，我们若记录以每个位置为中心的的回文串半径，我们可以通过另一个已确认的回文串中心把未确认的中心点对应过去提前赋值，这样可以帮助我们减少判断次数，优化时间复杂度。

假设目前未确认点为 $i$，已确认的且覆盖点 $i$ 的回文串中心、半径分别为 $mid$、$r$，那么点 $i$ 的对称点则为 $j=2\times mid-i$，那么 $j\leq mid \leq i$，点 $j$ 作为回文中心的最大回文半径 $r'$ 已经求得，我们可以预先确定一部分回文串，将点 $i$ 初值赋为 $\min(r', mid+r-i)$，至于为什么取 $\min$，因为大回文串右端点为 $mid+r-1$，点 $i$ 初赋值不能判断到大区间外面的点，那么我们每个点肯定会从右端点最靠右的回文串赋值过来，每次我们存一下右端点最靠右的回文串的中心、半径即可，如果点 $i$ 赋值为 $mid+r-i$ 了，我们就可以扩展半径判断是否可行（可以感性理解一下）

按照这样做，每个字符只会被循环访问到一次，所以时间复杂度为 $O(n)$，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, len[22000005], mid, mr, ans;
char s[11000005], t[22000005];
int main() {
	scanf("%s", s+1);
	n=strlen(s+1);
	for(int i = 1; i <= n; ++i) t[i*2]=s[i], t[i*2-1]='#';/*中间填上字符*/
	t[2*n+1]=t[0]='#', len[0]=len[1]=1, mid=1, mr=2;
	for(int i = 2; i <= 2*n+1; ++i) {
		if(i >= mr) len[i]=1;//比最右边还右边就直接赋值1
		else len[i]=min(len[mid*2-i], mr-i);//从之前那里继承一点从而优化时间复杂度
		while(t[i+len[i]] == t[i-len[i]]) ++len[i];//暴力扩展
		if(i+len[i] > mr) {//更新
			mr=i+len[i];
			mid=i;
		}
	}
	for(int i = 1; i <= 2*n+1; ++i)
		ans=max(ans, (len[i]*2-1)/2);
	printf("%d\n", ans);
	return 0;
} 
```

