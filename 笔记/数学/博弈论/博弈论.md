# 博弈论

#### 巴什博弈

题目：有 $n$ 个石子，两个人轮流取，每次最多取 $m$ 个，最少取 $1$ 个，取完者获胜，问先手有没有必胜策略。

分析:
不难发现只要当前石子个数 $n|{m+1}$，无论对方取多少，你都可以取一次使得对方又面临 $n|{m+1}$ 的情况。

所以先手只需每次取 $n \bmod (m+1)$,就可以保证先手必胜，如果 $n|m+1$ 则先手必败。

#### 威佐夫博弈

题目：有两堆石子，两个人轮流去，每次可以从一堆中取若干个或从两堆中取相同的若干个，取完者获胜，问先手有没有必胜策略。

分析:
由于先手必胜的局面大于先手必败的局面，所以我们考虑枚举先手必败的局面，可以一步移动到必败局面的即是必胜局面。

先手必败的局面有：(0,0),(1,2),(3,5),(4,7),(6,10)⋯

最后我们发现 $\Large{\frac {a} {(b-a)}}$ $\approx \phi$ ，$\phi$ 是黄金分割比的倒数，约等于 $1.618$ 。

详细证明过于复杂，感兴趣的可以自行查询。

#### Nim (luogu P2197)

甲，乙两个人玩 nim 取石子游戏。

nim 游戏的规则是这样的：地上有 $n\leq {10^4}$ 堆石子（每堆石子数量小于 ），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这 $n$ 堆石子的数量，他想知道是否存在先手必胜的策略。

分析:
局面的状态由 $n$ 堆石子共同决定，当场上没有石子的时候就是先手必败的最终局面，同时这个局面也是 $S_1 \oplus S_2 \oplus S_3 \oplus S_4 \oplus ... = 0$ 的局面。

引理：当当前局面为 $S = S_1 \oplus S_2 \oplus S_3 \oplus S_4 \oplus ... = 0$ 时，即是先手必败局面。

证明：当为此局面时，如果已经没有石子了，显然先手必败，否则，无论怎么取都会使得局面变为 $S \neq 0$ ，此时一定存在一种取法使得后手让当前局面再次变为 $S = 0$ 。设当前局面为 $S = ...0001???...$ ，因为 $S_{hignbit} =1$ 所以存在一堆石子 $K$ 的 $S_{hignbit}$ 位上为 $1$ ，只需将 $K$ 的 $S_{highbit}$ 位及以后的 $K'$ 变为 $T = K' \oplus S$ ，后手只需在 $K$ 上取 $K' - T$ 即可。

#### 阶梯博弈

有 1-n 个阶梯，0 号阶梯是地面，每个阶梯上都有一堆石子，两人轮流操作，每次操作可选择一个阶梯向左移动任意至少一个石子，当无法移动时也就是石子全部在地上游戏结束。

定理：

阶梯博弈等效于奇数号阶梯的 Nim 游戏和。

证明：

当对方移动奇数号石子时与 Nim 无异，当对方移动偶数号石子时，奇数号石子数量改变了，但是你可以将奇数号石子增加的石子又移回偶数号。证毕。



## SG 函数

如果每次都猜结论慢慢找规律，博弈论未免也太难了，所以我们这里引入 SG 函数。


### 前置芝士

#### ICG 游戏

关于 ICG 游戏，它的定义如下，需要满足三个条件：

1. 游戏有两人参与，两人轮流做出决策，并且两人做出的决策都是对自己最优的。

2. **当有一人无法决策的时候，该人失败**。无论两人如何决策，该游戏都必然会在有限时间内结束。

3. 游戏中同一个状态不能达到多次，且游戏没有平局。游戏者在某个确定状态做出的决策集合只与状态有关，与游戏者无关。 

之前介绍过的三种博弈模型，本质上都属于 ICG 游戏。

#### 必胜态与必败态

也就是奇异状态与非奇异状态，我们定义P状态是必败态，N状态是必胜态。我们可以简单理解成，**在P状态的玩家一定会输，而在N状态的玩家一定会赢**。

这一点在之前的Nim取子的文章当中我们曾经深入地分析过，展开来说，其实也有三条：

1. 无法移动的状态为 P 状态。
2. 可以移动到 P 状态的状态为 N。
3. 所有移动都会进入 N 局面的局面为 P。

我们曾经在分析威佐夫博弈问题的时候，将游戏局面抽象成了二维平面坐标系当中的点。其实所有 **ICG 游戏都可以想象成一张有向无环图（DAG）**，游戏开始时有一颗放在起点的棋子，两个玩家轮流移动棋子，直到不能移动的玩家落败。所有只能移动到终点的局面都是必胜的，所有只能连接必胜点的点是必败的。我们用递归或 DP 的思路可以计算出所有点的状态。

#### Sprague-Grundy数的推导

SG 是 Sprague-Grundy 的缩写，这是两个人名，它使用起来非常简单，但是推导过程有些复杂。如果我们忽略推导过程直接去研究它的使用的话，你会有一种在运用魔法的感觉。因为你完全猜测不到它其中的原理，所以我们需要详细解释一下它的推导过程，这样才能加深理解。

我们先明确几个概念，首先对于 ICG 游戏来说，**失败的最终状态只有一个，就是无法移动的点**，可以认为是 DAG 图中的终点。从这个终点倒推，所有能够直接连接终点的点是 N 点。这个很好理解，假如在当前的状态当中，可以移动到一个对手的必败状态，那么对于当前玩家当然是必胜的。

我们对这些状态做一个简单的分层，**直接可以连接 P 点的点是一级胜态**。比如 nim 游戏当中的 (1, 0) 状态就是一级胜态，它只能通往 P 点。我们把**可以变成败态也可以进入一级胜态的点称为二级胜态**，比如 nim 游戏当中的 (0, 2)。比如它进入 (1, 0) 便是一级胜态，而也可以直接进入 (0, 0) 变成败态，我们把这样的状态称为二级胜态。类似的，**如果一个胜态可以变成败态也可以变成 1 至 n-1 级的所有胜态，则称为 n 级胜态**，败态可以认为是 0 级胜态。

接着我们来看胜态的组合，我们可以把 Nim 取子问题中的结论照搬过来。**两个同级的胜态组合是败态**，**两个不同级的胜态组合是胜态**。原因也很简单，就和 Nim 取子问题中面临两堆同样多的石子必败一样。因为后手可以拷贝先手的操作，直到无法继续操作，游戏结束。而两个不同的胜态，先手可以将其中一个转化成和另一个一样，从而让后手面临两个一样的胜态，所以不同的胜态组合是胜态。

注意这个结论要成立，有两个前提条件，第一个是**一个 n 级胜态可以转移到1 - n-1 级任意胜态**。第二个是**胜态级数只能降低不能升高**，其实能升高也没问题，后手可以将先手升高的级数再降低回去，并不会影响结论。

不难发现其实我们对级数的定义其实就是 SG 函数的值。SG 函数能够用来将一个状态映射成一个非负整数的值。它的公式可以写成：

$$SG(A)=mex(SG(B) | A\rightarrow B)$$

式子中的 **A 和 B 表示状态**，$A\rightarrow B$ 表示 A 状态可以达到 B 状态。其中 mex 是一个定义在集合上的函数，返回的是不属于这个集合的最小自然数。比如 $mex(0, 1)=2，mex(0, 2)=1, mex(0,1, 2, 3)=4$。也就是说我们可以**通过 A 能达到的状态的 SG 函数值推算出 A 的 SG 值**。

比如在 Nim 取子问题当中，没有石子是必败，它没有后继状态，所以 $SG(0)=0$。1 颗石子的时候可以移动到 0，所以 $SG(1)=mex\{SG(0)\}=1$。这样我们**就把 Nim 取子问题和 ICG 问题当中胜态的级数对应起来了**。一个 SG 数对应 Nim 当中的一个石子堆，如果我们有多个石子堆，我们怎么计算开始时候的胜负状态？通过Nim取子问题的推导，我们知道是计算各个石子堆石子数量的异或值，如果异或之后的结果为 0，那么先手必败，否则先手必胜。同样我们计算所有状态的SG值，如果**最后得到的 SG 值亦或的结果为 0，说明先手必败，否则先手必胜**。

然后我们可以得到下式：

$$SG(A+B)=SG(A)\oplus SG(B)$$



----------------------------

现在我们知道通过 SG 函数可以轻松求得一系列 ICG，所以博弈论最为关键就在于如何快速的求出 SG 函数。

对于 SG 函数不固定的题目，我们大多数采取 **DP** 或 **记忆化搜索** 来动态求 SG 函数，较为高效。

对于 SG 函数固定的题目，数据在接受范围内，我们也可以采用上述方法。但数据过大时需要我们找到 SG 函数的通式了，如果你非常 nb 可以直接数学证明，但我们最常用的方法是打表找规律，方法较笨但实用性很高。


下面有一些例题练习如何求 SG 函数。

---------------



# 例题

## S-Nim

将 Nim 扩展一下，我们定义一个集合 $S=\{p_1,p_2,...,p_k\}(k∈Z^*)$，$A,B$ 在游戏的时候取走的石子数必须是集合里的数，其他条件不变。这是道模板题。



```cpp
int n,a[10001],sg[10001];
bitset<110> vis;
void prepare() {
	sort(a+1,a+n+1);
	memset(sg,0,sizeof(sg));
	for(int i=1; i<=10000; ++i) {
		vis.reset();
		for(int j=1; j<=n; ++j) {
			if(i<a[j]) break;
			vis[sg[i-a[j]]]=1;
		}
		for(int j=0; j<=100; ++j)	
			if(!vis[j]) {sg[i]=j;break;}
	}
}
```

---------------

## 取石子游戏1

有 $n$ 个石子，$A,B$ 两人轮流取石子，规定他们每次至多只能取当前石子总数$\Large{⌈\frac {s} {2}}⌉$个石子，问 $A$ 先手是否有必胜策略。



这题主要是为了加强大家对SG函数的理解，我们考虑从 $0$ 开始。

$$SG(0)=0,SG(1)=1,SG(2)=0,SG(3)=mex\{SG(3−1),SG(3−2)\}=2$$
$$SG(4)=mex\{SG(4−1),SG(4−2)\}=1...$$

我们把他们列出来找下规律：

```erlang
0,1
0,2,1,3
0,4,2,5,1,6,3,7
0,8,4,9,2,10...
```

我们发现有个很奇怪的规律：数列在间隔递增，上一行的数间隔着插在下一行的数中间。这就是这道题的 SG 函数，当且仅当 SG 函数为 $0$ 时必败。

------------------

## 取石子游戏2

假设有n堆石子，每堆当中有若干个石子。现在两个人轮流从其中取石子，一个人可以选择从任意一堆石子当中取走若干个石子，或者是**选择一堆大于1颗石子的石堆将它拆分成两堆**。最后无法取走石子的人落败，请问给定每堆石子的数量，谁会获胜。



这题如果去除掉石堆可以拆分的限制，那么它就是一道裸的 Nim 取子问题。但是加上了限制之后，我们就无法直接使用 Nim 取子的规则来求解了。但是我们分析一下会发现，这个虽然加上了限制条件，但是**仍然满足 ICG 游戏的限制**，所以我们可以使用 SG 函数来求解。

对于状态 N 来说，它可以转移到 0-N-1 任意状态，并且可以拆分成i和N-i两个状态。根据上文的公式：$SG(A+B)=SG(A)\oplus SG(B)$，所以我们 SG(N) 而言，它可以转移到 0-N-1 状态，以及 (i, N-i) 状态。

根据状态之间的关系，我们可以很容易写出求解 SG 函数的代码：

```cpp
const int N=1000;
int n,sg[N],vis[N];
void prepare() {
     sg[0]=0;
     for(int i=1;i<=n;++i) {
        for(int j=0;j<i;++j) {
           vis[sg[j]]=i;
           if(i!=1) vis[sg[j]^sg[i-j]]=1;
        }
        for(int j=0;vis[j]==i;++j) sg[i]=j+1;
     }
}
```

其实这已经比较优秀了，时间复杂度为 $\Theta(n^2·\log_2n)$，但数据一大就 T 飞了。

但我们通过打表可得：
$$
SG(n)= \left \{ 
\begin{aligned} 
n-1 & &(n\equiv0\mod4)\\
n+1 & &(n\equiv3\mod4)\\
n   & &(n\equiv other \mod4)
\end{aligned}
\right.
$$

---------

## [HNOI2007]分裂游戏

### 题目描述

聪聪和睿睿最近迷上了一款叫做分裂的游戏。

该游戏的规则是： 共有 $n$ 个瓶子， 标号为 $0, 1, \ldots, n-1$，第 $i$ 个瓶子中装有 $p_i$ 颗巧克力豆，两个人轮流取豆子，每一轮每人选择 $3$ 个瓶子，标号为 $i,j,k$, 并要保证 $i \lt j, j \leq k$，且第 $i$ 个瓶子中至少要有 $1$ 颗巧克力豆，随后这个人从第 $i$ 个瓶子中拿走一颗豆子并在 $j,k$ 中各放入一粒豆子（$j$ 可能等于 $k$） 。如果轮到某人而他无法按规则取豆子，那么他将输掉比赛。胜利者可以拿走所有的巧克力豆！

两人最后决定由聪聪先取豆子，为了能够得到最终的巧克力豆，聪聪自然希望赢得比赛。他思考了一下，发现在有的情况下，先拿的人一定有办法取胜，但是他不知道对于其他情况是否有必胜策略，更不知道第一步该如何取。他决定偷偷请教聪明的你，希望你能告诉他，在给定每个瓶子中的最初豆子数后是否能让自己得到所有巧克力豆，他还希望你告诉他第一步该如何取，并且为了必胜，第一步有多少种取法？

$1 \leq t \leq 10$，$2 \leq n \leq 21$，$0 \leq p_i \leq 10^4$，

### 分析：

不难发现这道题与奇偶有关，对于偶数的堆后手始终可以复制先手的操作，所以对答案没有影响。所以最终是否能赢就在于 $SG(i)|a_i\equiv1\mod2$ 的异或和。

因为数据较小，所以我们可以 $n^3$ 暴力预处理出 SG 函数，再暴力枚举第一步。

$$ SG(i)=mex(SG(j)\oplus SG(k)|j>i,k\geq j)$$

```cpp
int T,n,res,a[22],sg[22];
bitset<50> vis;
void prepare() {
	for(int i=2;i<=21;++i) {
		vis.reset();
		for(int j=1;j<i;++j) 
			for(int k=1;k<=j;++k) 
				vis[sg[j]^sg[k]]=1;
		for(int j=0;;++j) if(!vis[j]) {sg[i]=j;break;}
	}
}
void work() {
	int p1=-1,p2=-1,p3=-1,tot=0;
	for(int i=n;i>1;--i) {
		if(!a[i]) continue;
		for(int j=i-1;j;--j) 
			for(int k=j;k;--k) 
				if((res^sg[i]^sg[j]^sg[k])==0) {
					++tot;
					if(p1==-1) p1=n-i,p2=n-j,p3=n-k;
				}
	}
	printf("%d %d %d\n%d\n",p1,p2,p3,tot);
}
signed main() {
	prepare(),T=read();
	while(T--) {
		n=read(),res=0;
		for(int i=n;i;--i) a[i]=read();
		for(int i=n;i;--i) if(a[i]&1) res^=sg[i];
		if(!res) puts("-1 -1 -1\n0"); else work();
	}
	return 0;
}
```

---------------------

## [COCI2010-2011#4] HRPA

## 题目描述

有 $n$ 枚石子。两位玩家定了如下规则进行游戏：

- Mirko 先取一次，Slavko 再取一次，然后 Mirko 再取一次，两人轮流取石子，以此类推；
- Mirko 在第一次取石子时可以取走任意多个；
- 接下来，每次至少要取走一个石子，最多取走上一次取的数量的 $2$ 倍。当然，玩家取走的数量必须不大于目前场上剩余的石子数量。
- 取走最后一块石子的玩家获胜。

双方都以最优策略取石子。Mirko 想知道，自己第一次至少要取走几颗石子最终才能够获胜。

对于 $100\%$ 的数据，保证 $2\le n\le 10^{15}$。

### 分析：

可能一时间无从下手，单用一维石子数量不好表示游戏局面，所以我们可以再开一维，用 $SG(i,j)$ 表示局面 i 个石子，最多取 j 个石子属于几级胜态。
$$ SG(i,j)=mex(SG(i-k,k*2)|1\leq k\leq\min(i,j))$$

```cpp
int n,sg[1000][1000];
bitset<500> vis;
void prepare() {
	sg[0][0]=0;
	for(int i=1;i<=100;++i) {
		for(int j=1;j<=100;++j) {
			vis.reset();
			for(int k=1;k<=min(i,j);++k) vis[sg[i-k][k*2]]=1;
			for(int k=0;;++k) if(!vis[k]) {sg[i][j]=k;break;}
		}
	} 
}
```

然后我们就可以打表了。

1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 34 1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 51 1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 51 1 2 3 1 5 1 2 8 1 2 3 ......

不难发现答案的规律是斐波拉契两项之间又嵌套着斐波拉契。

$$
Ans(n)= \left \{ 
\begin{aligned} 
f(k) & &(f(k)=n) \\
Ans(n-f(k-1)) & &(f(k)>n)
\end{aligned}
\right.
$$

详细证明请自行分析(本人不会)。

-------------------

## 「Wdoi-6」另一侧的月

### 题目描述

给定 $n$ 个节点的树（保证 $n\ge 2$），Hifuu 和 Luna 交替操作，前者先手。每回合操作者选择一个节点，将「该节点」和「所有与该节点相连的边」删除，形成若干个连通块，操作者再从中保留一个连通块。如果该回合结束后只剩下一个节点，则该回合的操作者失败，另一个人胜利。问谁存在必胜策略。

对于 $100\%$ 的数据：$1 \leq T \leq 5$，$2 \le n \le 10^5$，输入数据构成一棵树。

分析：
这道题状态较为复杂，是一棵树，SG 函数求起来较麻烦，状态也不好表示，所以只能认真分析。

我们发现只有两个点时就是必败态，再加一条边又变成了必胜态，固定一个中心点，再添一条边又变成了必败态，所以我们可以得到，对于一个菊花图，如果有偶数条边就是必胜态，否则就是必败态。因为是树，所以只要我们可以在原树上抽出一个边数为偶数的菊花图，并将它与原树的连边切断，就能保证胜利。

只要存在度数为偶数的点就能保证胜利，如果存在度数为偶数的点连接叶子节点，显然可以抽出菊花图。如果都不连接则可将边缘的度数为偶数的点从树中割离，可得到一个点度数全为奇数的子树，此时无论后手割哪条边都使得有点度数为偶数，如果不存在度数为偶数的点则必败，证明同上。

---------------------
## [POI2009]KAM-Pebbles

### 题目描述

有 n 堆石子，除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作每次操作可以从一堆石子中移走任意多石子，但是要保证操作后仍然满足初始时的条件谁没有石子可移时输掉游戏。问先手是否必胜。

### 输入格式

第一行只有一个整数 n（1<=n<=1000），表示石子堆数；

第二行有 n 个整数用空格隔开，第 i 个整数 $a_i$ 表示第 i 堆的石子个数，保证 $a_1<=a_2<=a_3...<=a_n$ 。

保证石子总数不超过 10000。

分析：

每堆石子最多可拿的数量为 $a_i-a_{i-1}$,也就是 a 的差分数组。考虑在第 i 堆取 x 个石子，那么就相当于 $c_i\leftarrow c_i-x,c_{i+1}\leftarrow c_{i+1}+x$, 然后终态是 $a_0=sum,c_n=sum$。我们发现这其实相当于有 n 堆石子，每次可选一堆石子并将移动一些石子到下一堆，不能移动的输。很明显是个倒着的阶梯博弈，直接对 n 对应的奇偶堆取差分数组异或和就行。

-------------------
## [CQOI2013]棋盘游戏

### 题目描述

一个 n*n（n>=2）棋盘上有黑白棋子各一枚。游戏者 A 和 B 轮流移动棋子，A 先走。

 * A 的移动规则：只能移动白棋子。可以往上下左右四个方向之一移动一格。

 * B 的移动规则：只能移动黑棋子。可以往上下左右四个方向之一移动一格或者两格。

和通常的“吃子”规则一样，当某游戏者把自己的棋子移动到对方棋子所在的格子时，他就赢了。

两个游戏者都很聪明，当可以获胜时会尽快获胜，只能输掉的时候会尽量拖延时间。你的任务是判断谁会赢，需要多少回合。


比如 $n=2$，白棋子在 $(1,1)$，黑棋子在 $(2,2)$，那么虽然A有两种走法，第二个回合B总能取胜。

### 输入格式

仅一行，包含五个整数n, r1, c1, r2, c2，即棋盘大小和棋子位置，黑白棋子的位置保证不相同。
$n<=20$

分析：

这题一点也不博弈，只有 A 第一步就可以吃掉 B 时 A 才能赢，之后直接记忆化搜索就行了，A 取时间 max, B 取时间 min。

-------------------
## [ZJOI2009]染色游戏

### 题目描述

一共 n×m 个硬币，摆成 n×m 的长方形。dongdong 和 xixi 玩一个游戏， 每次可以选择一个连通块，并把其中的硬币全部翻转，但是需要满足存在一个硬币属于这个连通块并且所有其他硬币都在它的左上方(可以正左方也可以正上方)，并且这个硬币是从反面向上翻成正面向上。dongdong 和 xixi 轮流操作。如果某一方无法操作，那么他(她)就输了。dongdong 先进行第一步操作，假设双方都采用最优策略。问 dongdong 是否有必胜策略。

### 输入格式

第一行一个数 T，表示他们一共玩 T 局游戏。接下来是 T 组游戏描述。每组游戏第一行两个数 n,m，接下来 n 行每行 m 个字符，第 i 行第 j 个字符如果是 “H” 表示第 i 行第 j 列的硬币是正面向上，否则是反面向上。第 i 行 j 列的左上方是指行不超过 i 并且列不超过 j 的区域。

$1\leq n,m\leq 100,1 \leq T\leq 50$。

分析：

首先我们得知道一个局面的 SG 函数为所有反面硬币的独立 SG 函数的异或和，没有这个这道题基本上就不可做。详细证明我不会，网上也没有一篇证明的博客，感性理解就行。

然后我们考虑如何去求 SG(i,j)，对于 $i==1||j==1$ 这就是一个一维翻硬币问题，容易发现此时的 SG 函数的值为 $lowbit(i+j-1)$, 然后就可以对其它状态进行打表了，而规律非常简单，$SG(i,j)=2^{i+j-2}$。

所以有下式:

$$
SG(i,j)= \left \{ 
\begin{aligned} 
lowbit(i,j) && (i=1|j=1)\\
2^{i+j-2} && (i!=1 \& j!=1)
\end{aligned}
\right.
$$

--------------

## [ZJOI2009]取石子游戏

### 题目描述

在研究过 Nim 游戏及各种变种之后，Orez 又发现了一种全新的取石子游戏，这个游戏是这样的：

有 $n$ 堆石子，将这 $n$ 堆石子摆成一排。游戏由两个人进行，两人轮流操作，每次操作者都可以从最左或最右的一堆中取出若干颗石子，可以将那一堆全部取掉，但不能不取，不能操作的人就输了。

Orez 问：对于任意给出一个初始一个局面，是否存在先手必胜策略。

$1 \le n \le 1000$，$1 \le a_i \le {10}^9$。

### 题解:

说实话我真不知道这道题和 SG 函数有什么关系，先不说状态过于繁杂，SG 函数也是毫无规律可循。无奈只有查看题解。

首先设 $L[i][j]$ 表示在 $[i,j]$ 这一段区间的左侧放上一堆数量为 $L[i][j]$ 的石子后，先手必败。同理定义 $
R[i][j]$ 表示右侧。

首先我们可以证明 $L[i][j]$ 具有唯一性，因为如果存在多个,显然大的那个可以转移到小的那个，但小的那个先手必败，所以大的那个先手必胜，这与定义不符，证毕。

接下来考虑如何证明 $L[i][j]$ 一定存在。假设 $L[i][j]$ 不存在，那么对于这段区间而言，在左边加上任意一堆石子先手都必胜，既然先手必胜意味着先手进行一步操作之后可以到达一个必败态，这里分情况讨论。假设先手拿的是最左边的一堆石子，因为不存在 $L[i][j]$，所以只要拿了左边的石子之后，当前局面都是必胜态，所以不可能拿左边的石子。那么只能拿右边的石子，那么无论右边拿了一定量之后，无论左边添加了多少，都是一个必败态，那么此时后手在左侧随便拿走一定数量，这个状态也还是一个必败态，显然也不成立。因此 $L[i][j]$ 必定存在。

综上，我们知道了 $L[i][j]$ 一定存在并且唯一，而 $L[][],R[][]$ 显然是对称的，因此 $R[i][j]$ 也满足上述性质。

现在考虑如何求解 $L[i][j]$,$R[i][j]$ 同理。首先边界情况显然，$L[i][i]=a[i]$，因为只剩下两堆一模一样的情况的时候，后手只需要模仿先手的行动对称执行就好了，这样子一定不会输，即先手必败。

接下来来大力分类讨论，为了方便，设 $L=L[i][j−1],R=R[i][j−1],x=a[j]$。

* $x=R$

   这种情况下显然只需要直接把 $a[j]$ 放进去就好了，即这个区间本身就是一个必败态。所以 $L[i][j]=0$。

* $x<L,x<R$

  这种情况下 $L[i][j]=x$。这种情况下最靠左的 $L[i][j]$ 和 $x=a[j]$ 是相同的，意味着先手无论怎么取，后手显然可以学着它的方法取，也就意味着左右两堆中显然必然会先拿完一堆，此时后手学着拿的那一堆的石子数一定也是小于 $L,R$ 的。假设先手先拿完了最靠右的一堆，即剩下了$[i,j−1]$，因为 $L[i][j−1]$ 表示的是在这一段区间最左侧加入一个 $L[i][j−1]$ 的堆，无论先手怎么取先手都是必败的，那么我们等价的认为先手取走了这一堆的一部分，显然后手是必胜的。假如先手先取完的是最左的一堆，同理，$R[i][j−1]$ 的含义是在最右侧加入了一堆，而 $a[j]<R[i][j−1]$，我们还是可以等价的认为先手在这一堆中取走了若干石子，而这个状态对于先手而言是必败状态，因此显然后手必胜。

* $R<x<L$

    这种情况下 $L[i][j]=x−1$。这样子考虑，假设先手先拿了左边这一堆，那么假设还剩下了 $z$ 个石子，如果 $z<R$，后手把右侧的那一堆也给拿成 $z$ 就变成了上面的情况。如果 $z\geq R$，那么后手把最后那一堆拿成 $z+1$，于是又回到了这种情况，相当于这种情况递归处理。如果先手先拿的是右侧的这一堆，还是一样的，假设把它拿成了$z$，如果 $z<R$，同上可以变成 $x<L,x<R$ 的情况；如果 $y=R$，直接把左边拿完，就变成了$R[i][j−1]$ 的定义了，先手必败；如果 $z>R$，把左边那堆变成 $z−1$，同样递归处理。

* $L<x<R$

    分析同上，$L[i][j]=x+1$。

* $x>L,x>R$

    $L[i][j]=x$。还是一样的，假设先手把其中一堆拿成了$z$。如果 $z>L,R$，跟着先手拿成一样多的石子则又回到了这种情况。如果 $z<L,R$,则可以回到情况 $x<L,R$。否则的话对应着把另外一堆变成 $z+1$ 或者 $z−1$，对应着 $L<x<R$ 两种情况。

而 $R[][]$和 $L[][]$ 是对称的，类似的求解即可。

那么最终只需要判断 $L[2][n]$ 和 $a[1]$ 是否相等即可判断胜负情况。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[1010],L[1010][1010],R[1010][1010];
signed main() {
	n=read();
	for(int i=1;i<=n;++i) L[i][i]=R[i][i]=a[i]=read();
	for(int l=n;l>=1;--l) {
		for(int r=l+1;r<=n;++r) {
			int x=a[r],lx=L[l][r-1],rx=R[l][r-1];
			if(x==rx) L[l][r]=0;
			else if(x<lx&&x<rx||x>lx&&x>rx) L[l][r]=x;
			else if(lx<=x&&x<rx) L[l][r]=x+1;
			else L[l][r]=x-1;
			x=a[l],lx=L[l+1][r],rx=R[l+1][r];
			if(x==lx) R[l][r]=0;
			else if(x<lx&&x<rx||x>lx&&x>rx) R[l][r]=x;
			else if(rx<x&&x<lx) R[l][r]=x+1;
			else R[l][r]=x-1;
		}
	}
	puts(L[2][n]==a[1]?"0":"1");
	return 0;
}

```
--------------------

## [HNOI2010]取石头游戏

### 题目描述

A 公司正在举办一个智力双人游戏比赛 - 取石子游戏，游戏的获胜者将会获得 A 公司提供的丰厚奖金，因此吸引了来自全国各地的许多聪明的选手前来参加比赛。

与经典的取石子游戏相比，A 公司举办的这次比赛的取石子游戏规则复杂了很多：

* 总共有 $N$ 堆石子依次排成一行，第 $i$ 堆石子有 $a_i$ 个石子。

* 开始若干堆石子已被 A 公司故意拿走。

* 然后两个玩家轮流来取石子，每次每个玩家可以取走一堆中的所有石子，但有一个限制条件：一个玩家若要取走一堆石子，则与这堆石子相邻的某堆石子已被取走(之前被某个玩家取走或开始被 A 公司故意拿走)。注意：第 $1$ 堆石子只与第 $2$ 堆石子相邻，第 $N$ 堆石子只与第 $N-1$ 堆石子相邻，其余的第 $i$ 堆石子与第 $i-1$ 堆和第 $i+1$ 堆石子相邻。

* 所有石子都被取走时，游戏结束。谁最后取得的总石子数最多，谁就获得了这场游戏的胜利。

作为这次比赛的参赛者之一，绝顶聪明的你，想知道对于任何一场比赛，如果先手者和后手者都使用最优的策略，最后先手者和后手者分别能够取得的总石子数分别是多少。

### 输入格式

第一行是一个正整数 $N$，表示有多少堆石子。输入文件第二行是用空格隔开的 $N$ 个非负整数 $a_1, a_2,\ldots, a_N$，其中 $a_i$ 表示第 $i$ 堆石子有多少个石子，$a_i  = 0$ 表示第 $i$ 堆石子开始被 A 公司故意拿走。输入的数据保证 $0\leq a_i\leq 10^8$，并且至少有一个 $i$ 使得 $a_i = 0$。

$100\%$ 的数据满足 $2\leq N\leq 10^6$。

#### 分析:

每一段都是独立游戏，互不影响，先手最优可以转化为令差值尽可能大，后手最优可以转化为令差值尽可能小，最后用差值和总和解出方程的解即可。

$n^2$ 的区间 dp 最后合并应该不难想，然后我们考虑有三个数 $a,b,c$， 其中 $b\geq\max(a,c)$ 此时先手取 $a$ 或 $c$ 后手一定取 $b$，所以我们可将这样的 “ 峰 ” 三元组转化为 $a+c-b$，全部转化完后就只会剩下一些 "谷”,对于中间的显然可以将他们排序后从大到小取，最大的一定在边缘，所以合法，而两边从内到外单减部分可与上一起处理，最后剩下一些，如果有偶数个先取一定不会最优，所以将中间取完了再按顺序取即可，如果是奇数，因为递增的递减部分一定存在交点，取走保证偶数即可。

--------------------
## [SNOI2020] 取石子

### 题目描述

甲乙两个人玩取石子游戏。他们面前有一堆共 $n$ 个石子，然后由甲先手，两人轮流从中取走石子：甲第一次取走的个数不能超过 $k$，接下来每个人取走的个数不能超过上一个人刚刚取走个数的 $2$ 倍。每人每次必须至少取一个石子。取走最后一个石子的人失败，另一方获胜。现在已知 $k$，请你求出在 $1$ 到 $N$ 中有多少整数 $n$ 使得甲在 $n$ 颗石子的游戏中有必胜策略。


#### 数据说明与提示

对于所有数据，$1 \le T \le 10^5,k,N \le 10^{18}$。

#### 分析：

和之前那道一样都是斐波拉契，SG 函数类似，对于每一个正整数都可以表示为几个不连续的斐波拉契数之和，每个数都有唯一表示，所以我们可以得到一种斐波拉契进制，这可以由齐肯多夫定理证明（自行了解），然后答案可以表示为:

$$ans(i)=\sum_1^n k\geq Flowbit(i)$$

$Flowbit(x)$ 表示 $x$ 的最低位斐波拉契数。

最后数位 DP 或前缀和优化即可。
